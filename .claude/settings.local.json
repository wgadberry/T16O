{
  "permissions": {
    "allow": [
      "Bash(/dev/null <<'EOF'\n-- Well-known Solana programs\nINSERT INTO addresses (address, address_type, label) VALUES\n-- System programs\n('11111111111111111111111111111111', 'program', 'System Program'),\n('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA', 'program', 'Token Program'),\n('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb', 'program', 'Token-2022 Program'),\n('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL', 'program', 'Associated Token Account Program'),\n('ComputeBudget111111111111111111111111111111', 'program', 'Compute Budget Program'),\n('Sysvar1nstructions1111111111111111111111111', 'program', 'Sysvar Instructions'),\n('SysvarRent111111111111111111111111111111111', 'program', 'Sysvar Rent'),\n('SysvarC1ock11111111111111111111111111111111', 'program', 'Sysvar Clock'),\n('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr', 'program', 'Memo Program v2'),\n('Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo', 'program', 'Memo Program v1'),\n\n-- DEX programs\n('JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4', 'program', 'Jupiter v6'),\n('JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB', 'program', 'Jupiter v4'),\n('whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc', 'program', 'Orca Whirlpool'),\n('9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP', 'program', 'Orca Swap v2'),\n('CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK', 'program', 'Raydium CPMM'),\n('675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8', 'program', 'Raydium AMM v4'),\n('CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C', 'program', 'Raydium CLMM'),\n('LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo', 'program', 'Meteora DLMM'),\n('Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB', 'program', 'Meteora Pools'),\n('srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX', 'program', 'Serum DEX v3'),\n('PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY', 'program', 'Phoenix'),\n('6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P', 'program', 'Pump.fun'),\n\n-- Lending/DeFi\n('MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA', 'program', 'MarginFi'),\n('So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo', 'program', 'Solend'),\n('JD3bq9hGdy38PuWQ4h2YJpELmHVGPPfFSuFkpzAd9zfu', 'program', 'Mango v4'),\n('DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1', 'program', 'Drift'),\n\n-- NFT/Metaplex\n('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s', 'program', 'Metaplex Token Metadata'),\n('p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98', 'program', 'Metaplex Core'),\n('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY', 'program', 'Metaplex Bubblegum'),\n\n-- Staking\n('Stake11111111111111111111111111111111111111', 'program', 'Stake Program'),\n('SPoo1Ku8WFXoNDMHPsrGSTSG1Y47rzgn41SLUNakuHy', 'program', 'Stake Pool Program'),\n('MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD', 'program', 'Marinade Finance'),\n('CgntPoLka5pD5fesJYhGmUCF8KU1QS1ZmZiuAuMZr2az', 'program', 'Jito Stake Pool'),\n\n-- Well-known mints\n('So11111111111111111111111111111111111111112', 'mint', 'Wrapped SOL'),\n('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'mint', 'USDC'),\n('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', 'mint', 'USDT'),\n('mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', 'mint', 'mSOL'),\n('7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj', 'mint', 'stSOL'),\n('J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn', 'mint', 'JitoSOL'),\n('DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', 'mint', 'BONK'),\n('JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN', 'mint', 'JUP')\nON DUPLICATE KEY UPDATE \n    address_type = VALUES(address_type),\n    label = COALESCE(VALUES(label), addresses.label);\n\nSELECT 'Programs and mints loaded' as status;\nSELECT address_type, COUNT(*) as cnt FROM addresses GROUP BY address_type ORDER BY cnt DESC;\nSELECT COUNT(*) as labeled FROM addresses WHERE label IS NOT NULL;\nEOF)",
      "Bash(1 <<'EOF'\nINSERT INTO transactions (\n    signature,\n    slot,\n    block_time,\n    block_time_utc,\n    status,\n    success,\n    fee_payer_id,\n    program_id,\n    account_keys,\n    programs,\n    signers,\n    pre_balances,\n    post_balances,\n    pre_token_balances,\n    post_token_balances,\n    inner_instructions,\n    instructions,\n    logs,\n    address_table_lookups,\n    transaction_json\n)\nSELECT \n    tp.signature,\n    tp.slot,\n    tp.block_time,\n    tp.block_time_utc,\n    tp.status,\n    CASE WHEN tp.status = 'success' THEN TRUE ELSE FALSE END as success,\n    COALESCE(\n        (SELECT id FROM addresses WHERE address = JSON_UNQUOTE(JSON_EXTRACT(tp.account_keys, '$[0]'))),\n        (SELECT id FROM addresses WHERE address = 'So11111111111111111111111111111111111111112')\n    ) as fee_payer_id,\n    NULL as program_id,\n    tp.account_keys,\n    tp.programs,\n    tp.signers,\n    tp.pre_balances,\n    tp.post_balances,\n    tp.pre_token_balances,\n    tp.post_token_balances,\n    tp.inner_instructions,\n    tp.instructions,\n    tp.logs,\n    tp.address_table_lookups,\n    tp.tx_payload as transaction_json\nFROM solana_events.tx_payload tp\nLIMIT 5;\nEOF)",
      "Bash(1 <<'EOF'\n-- First ensure fee payer addresses exist\nINSERT IGNORE INTO addresses (address)\nSELECT DISTINCT JSON_UNQUOTE(JSON_EXTRACT(account_keys, '$[0]'))\nFROM solana_events.tx_payload\nWHERE account_keys IS NOT NULL;\n\n-- Now migrate transactions\nINSERT INTO transactions (\n    signature,\n    slot,\n    block_time,\n    block_time_utc,\n    status,\n    success,\n    err,\n    fee_lamports,\n    compute_units_consumed,\n    fee_payer_id,\n    program_id,\n    transaction_type,\n    version,\n    recent_blockhash,\n    transaction_json,\n    transaction_bin,\n    compression_type,\n    original_size,\n    programs,\n    instructions,\n    account_keys,\n    log_messages,\n    pre_balances,\n    post_balances,\n    pre_token_balances,\n    post_token_balances,\n    inner_instructions,\n    address_table_lookups,\n    rewards,\n    extended_attributes\n)\nSELECT \n    tp.signature,\n    tp.slot,\n    tp.block_time,\n    tp.block_time_utc,\n    tp.status,\n    CASE WHEN tp.status = 'success' THEN TRUE ELSE FALSE END,\n    tp.err,\n    tp.fee_lamports,\n    tp.computeUnitsConsumed,\n    (SELECT id FROM addresses WHERE address = JSON_UNQUOTE(JSON_EXTRACT(tp.account_keys, '$[0]'))),\n    NULL,\n    tp.transaction_type,\n    tp.version,\n    tp.recentBlockhash,\n    tp.transaction_json,\n    tp.transaction_bin,\n    tp.compression_type,\n    tp.original_size,\n    tp.programs,\n    tp.instructions,\n    tp.account_keys,\n    tp.log_messages,\n    tp.pre_balances,\n    tp.post_balances,\n    tp.pre_token_balances,\n    tp.post_token_balances,\n    tp.inner_instructions,\n    tp.address_table_lookups,\n    tp.rewards,\n    tp.extendedAttributes\nFROM solana_events.tx_payload tp\nWHERE NOT EXISTS (SELECT 1 FROM transactions t WHERE t.signature = tp.signature);\n\nSELECT COUNT(*) as transactions_migrated FROM transactions;\nEOF)",
      "Bash(1 <<'EOF'\n-- First ensure fee payer addresses exist with collation fix\nINSERT IGNORE INTO addresses (address)\nSELECT DISTINCT JSON_UNQUOTE(JSON_EXTRACT(account_keys, '$[0]')) COLLATE utf8mb4_0900_ai_ci\nFROM solana_events.tx_payload\nWHERE account_keys IS NOT NULL;\n\nSELECT CONCAT('Fee payer addresses ensured: ', COUNT(*)) as status FROM addresses;\nEOF)",
      "Bash(1 <<'EOF'\nINSERT INTO transactions (\n    signature,\n    slot,\n    block_time,\n    block_time_utc,\n    status,\n    success,\n    err,\n    fee_lamports,\n    compute_units_consumed,\n    fee_payer_id,\n    program_id,\n    transaction_type,\n    version,\n    recent_blockhash,\n    transaction_json,\n    transaction_bin,\n    compression_type,\n    original_size,\n    programs,\n    instructions,\n    account_keys,\n    log_messages,\n    pre_balances,\n    post_balances,\n    pre_token_balances,\n    post_token_balances,\n    inner_instructions,\n    address_table_lookups,\n    rewards,\n    extended_attributes\n)\nSELECT \n    tp.signature COLLATE utf8mb4_0900_ai_ci,\n    tp.slot,\n    tp.block_time,\n    tp.block_time_utc,\n    tp.status COLLATE utf8mb4_0900_ai_ci,\n    CASE WHEN tp.status = 'success' THEN TRUE ELSE FALSE END,\n    tp.err,\n    tp.fee_lamports,\n    tp.computeUnitsConsumed,\n    (SELECT id FROM addresses WHERE address = JSON_UNQUOTE(JSON_EXTRACT(tp.account_keys, '$[0]')) COLLATE utf8mb4_0900_ai_ci),\n    NULL,\n    tp.transaction_type COLLATE utf8mb4_0900_ai_ci,\n    tp.version COLLATE utf8mb4_0900_ai_ci,\n    tp.recentBlockhash COLLATE utf8mb4_0900_ai_ci,\n    tp.transaction_json,\n    tp.transaction_bin,\n    tp.compression_type COLLATE utf8mb4_0900_ai_ci,\n    tp.original_size,\n    tp.programs,\n    tp.instructions,\n    tp.account_keys,\n    tp.log_messages,\n    tp.pre_balances,\n    tp.post_balances,\n    tp.pre_token_balances,\n    tp.post_token_balances,\n    tp.inner_instructions,\n    tp.address_table_lookups,\n    tp.rewards,\n    tp.extendedAttributes\nFROM solana_events.tx_payload tp\nWHERE NOT EXISTS (SELECT 1 FROM transactions t WHERE t.signature = tp.signature COLLATE utf8mb4_0900_ai_ci);\n\nSELECT COUNT(*) as transactions_migrated FROM transactions;\nEOF)",
      "Bash(1 <<'EOF'\n-- Activity report for address: Hnxj8Fd9wMaYRWRW6YJP6zJF7nh3QTzM3KufGEuefD8v\n\nSET @target_address = 'Hnxj8Fd9wMaYRWRW6YJP6zJF7nh3QTzM3KufGEuefD8v';\n\n-- Get address info\nSELECT '=== ADDRESS INFO ===' as section;\nSELECT \n    a.id,\n    a.address,\n    a.address_type,\n    a.label,\n    COALESCE(p.address, '-') as parent_address,\n    COALESCE(p.label, '-') as parent_label,\n    COALESCE(prog.address, '-') as program_address,\n    COALESCE(prog.label, '-') as program_label\nFROM addresses a\nLEFT JOIN addresses p ON a.parent_id = p.id\nLEFT JOIN addresses prog ON a.program_id = prog.id\nWHERE a.address = @target_address;\n\n-- Transaction summary\nSELECT '=== TRANSACTION SUMMARY ===' as section;\nSELECT \n    tp.role,\n    COUNT(*) as tx_count,\n    SUM(CASE WHEN tp.token_mint_id IS NULL THEN tp.amount ELSE 0 END) as total_sol_lamports,\n    SUM(CASE WHEN tp.token_mint_id IS NOT NULL THEN tp.amount ELSE 0 END) as total_token_amount\nFROM transaction_participants tp\nJOIN addresses a ON tp.address_id = a.id\nWHERE a.address = @target_address\nGROUP BY tp.role\nORDER BY tx_count DESC;\n\n-- All transactions with details\nSELECT '=== TRANSACTION DETAILS ===' as section;\nSELECT \n    t.signature,\n    t.block_time_utc,\n    tp.role,\n    tp.amount,\n    COALESCE(mint.label, mint.address, 'SOL') as token,\n    tp.instruction_index,\n    tp.inner_instruction_index\nFROM transaction_participants tp\nJOIN addresses a ON tp.address_id = a.id\nJOIN transactions t ON tp.tx_id = t.id\nLEFT JOIN addresses mint ON tp.token_mint_id = mint.id\nWHERE a.address = @target_address\nORDER BY t.block_time DESC, tp.instruction_index;\n\n-- Counterparties (who did this address interact with)\nSELECT '=== TOP COUNTERPARTIES ===' as section;\nSELECT \n    other_addr.address,\n    other_addr.address_type,\n    COALESCE(other_addr.label, '-') as label,\n    COUNT(DISTINCT t.id) as shared_tx_count\nFROM transaction_participants tp\nJOIN addresses a ON tp.address_id = a.id\nJOIN transactions t ON tp.tx_id = t.id\nJOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.address_id != tp.address_id\nJOIN addresses other_addr ON tp2.address_id = other_addr.id\nWHERE a.address = @target_address\n  AND other_addr.address_type NOT IN ('program')  -- Exclude programs\nGROUP BY other_addr.id\nORDER BY shared_tx_count DESC\nLIMIT 20;\nEOF)",
      "Bash(1 <<'EOF'\nDROP PROCEDURE IF EXISTS sp_address_activity;\n\nDELIMITER //\n\nCREATE PROCEDURE sp_address_activity(\n    IN p_address CHAR(44)\n)\nBEGIN\n    DECLARE v_address_id INT UNSIGNED;\n    \n    -- Get address ID\n    SELECT id INTO v_address_id FROM addresses WHERE address = p_address;\n    \n    IF v_address_id IS NULL THEN\n        SELECT JSON_OBJECT('error', 'Address not found', 'address', p_address) as result;\n    ELSE\n        -- Address Info\n        SELECT \n            a.id,\n            a.address,\n            a.address_type,\n            a.label,\n            a.discovered_at,\n            COALESCE(p.address, NULL) as parent_address,\n            COALESCE(p.label, NULL) as parent_label,\n            COALESCE(prog.address, NULL) as program_address,\n            COALESCE(prog.label, NULL) as program_label\n        FROM addresses a\n        LEFT JOIN addresses p ON a.parent_id = p.id\n        LEFT JOIN addresses prog ON a.program_id = prog.id\n        WHERE a.id = v_address_id;\n        \n        -- Transaction Summary by Role\n        SELECT \n            tp.role,\n            COUNT(DISTINCT tp.tx_id) as tx_count,\n            SUM(CASE WHEN tp.token_mint_id IS NULL THEN tp.amount ELSE 0 END) as sol_lamports,\n            SUM(CASE WHEN tp.token_mint_id IS NOT NULL THEN tp.amount ELSE 0 END) as token_amount\n        FROM transaction_participants tp\n        WHERE tp.address_id = v_address_id\n        GROUP BY tp.role\n        ORDER BY tx_count DESC;\n        \n        -- Token Summary (which tokens were involved)\n        SELECT \n            COALESCE(mint.label, mint.address) as token,\n            mint.address as mint_address,\n            SUM(CASE WHEN tp.role = 'sender' THEN tp.amount ELSE 0 END) as sent,\n            SUM(CASE WHEN tp.role = 'receiver' THEN tp.amount ELSE 0 END) as received,\n            COUNT(DISTINCT tp.tx_id) as tx_count\n        FROM transaction_participants tp\n        JOIN addresses mint ON tp.token_mint_id = mint.id\n        WHERE tp.address_id = v_address_id\n          AND tp.token_mint_id IS NOT NULL\n        GROUP BY mint.id\n        ORDER BY tx_count DESC;\n        \n        -- Transaction Details\n        SELECT \n            t.id as tx_id,\n            t.signature,\n            t.block_time_utc,\n            t.status,\n            tp.role,\n            tp.amount,\n            CASE \n                WHEN tp.token_mint_id IS NULL THEN 'SOL'\n                ELSE COALESCE(mint.label, mint.address)\n            END as token,\n            mint.address as mint_address,\n            tp.instruction_index,\n            tp.inner_instruction_index\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        LEFT JOIN addresses mint ON tp.token_mint_id = mint.id\n        WHERE tp.address_id = v_address_id\n        ORDER BY t.block_time DESC, t.id, tp.instruction_index;\n        \n        -- Top Counterparties (non-program addresses that appear in same transactions)\n        SELECT \n            other_addr.address,\n            other_addr.address_type,\n            COALESCE(other_addr.label, NULL) as label,\n            COUNT(DISTINCT t.id) as shared_tx_count,\n            GROUP_CONCAT(DISTINCT tp2.role ORDER BY tp2.role SEPARATOR ', ') as roles\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        JOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.address_id != tp.address_id\n        JOIN addresses other_addr ON tp2.address_id = other_addr.id\n        WHERE tp.address_id = v_address_id\n          AND other_addr.address_type NOT IN ('program')\n        GROUP BY other_addr.id\n        ORDER BY shared_tx_count DESC\n        LIMIT 25;\n        \n        -- Programs Used\n        SELECT \n            prog.address,\n            COALESCE(prog.label, NULL) as label,\n            COUNT(DISTINCT t.id) as tx_count\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        JOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.role = 'program'\n        JOIN addresses prog ON tp2.address_id = prog.id\n        WHERE tp.address_id = v_address_id\n        GROUP BY prog.id\n        ORDER BY tx_count DESC\n        LIMIT 15;\n    END IF;\nEND //\n\nDELIMITER ;\n\nSELECT 'Procedure sp_address_activity created successfully' as status;\nEOF)",
      "Bash(1 <<'EOF'\nDROP PROCEDURE IF EXISTS sp_address_activity;\n\nDELIMITER //\n\nCREATE PROCEDURE sp_address_activity(\n    IN p_address CHAR(44)\n)\nBEGIN\n    DECLARE v_address_id INT UNSIGNED;\n    \n    -- Get address ID\n    SELECT id INTO v_address_id FROM addresses WHERE address = p_address;\n    \n    IF v_address_id IS NULL THEN\n        SELECT JSON_OBJECT('error', 'Address not found', 'address', p_address) as result;\n    ELSE\n        -- Address Info\n        SELECT \n            a.id,\n            a.address,\n            a.address_type,\n            a.label,\n            COALESCE(p.address, NULL) as parent_address,\n            COALESCE(p.label, NULL) as parent_label,\n            COALESCE(prog.address, NULL) as program_address,\n            COALESCE(prog.label, NULL) as program_label\n        FROM addresses a\n        LEFT JOIN addresses p ON a.parent_id = p.id\n        LEFT JOIN addresses prog ON a.program_id = prog.id\n        WHERE a.id = v_address_id;\n        \n        -- Transaction Summary by Role\n        SELECT \n            tp.role,\n            COUNT(DISTINCT tp.tx_id) as tx_count,\n            SUM(CASE WHEN tp.token_mint_id IS NULL THEN tp.amount ELSE 0 END) as sol_lamports,\n            SUM(CASE WHEN tp.token_mint_id IS NOT NULL THEN tp.amount ELSE 0 END) as token_amount\n        FROM transaction_participants tp\n        WHERE tp.address_id = v_address_id\n        GROUP BY tp.role\n        ORDER BY tx_count DESC;\n        \n        -- Token Summary (which tokens were involved)\n        SELECT \n            COALESCE(mint.label, mint.address) as token,\n            mint.address as mint_address,\n            SUM(CASE WHEN tp.role = 'sender' THEN tp.amount ELSE 0 END) as sent,\n            SUM(CASE WHEN tp.role = 'receiver' THEN tp.amount ELSE 0 END) as received,\n            COUNT(DISTINCT tp.tx_id) as tx_count\n        FROM transaction_participants tp\n        JOIN addresses mint ON tp.token_mint_id = mint.id\n        WHERE tp.address_id = v_address_id\n          AND tp.token_mint_id IS NOT NULL\n        GROUP BY mint.id\n        ORDER BY tx_count DESC;\n        \n        -- Transaction Details\n        SELECT \n            t.id as tx_id,\n            t.signature,\n            t.block_time_utc,\n            t.status,\n            tp.role,\n            tp.amount,\n            CASE \n                WHEN tp.token_mint_id IS NULL THEN 'SOL'\n                ELSE COALESCE(mint.label, mint.address)\n            END as token,\n            mint.address as mint_address,\n            tp.instruction_index,\n            tp.inner_instruction_index\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        LEFT JOIN addresses mint ON tp.token_mint_id = mint.id\n        WHERE tp.address_id = v_address_id\n        ORDER BY t.block_time DESC, t.id, tp.instruction_index;\n        \n        -- Top Counterparties (non-program addresses that appear in same transactions)\n        SELECT \n            other_addr.address,\n            other_addr.address_type,\n            COALESCE(other_addr.label, NULL) as label,\n            COUNT(DISTINCT t.id) as shared_tx_count,\n            GROUP_CONCAT(DISTINCT tp2.role ORDER BY tp2.role SEPARATOR ', ') as roles\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        JOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.address_id != tp.address_id\n        JOIN addresses other_addr ON tp2.address_id = other_addr.id\n        WHERE tp.address_id = v_address_id\n          AND other_addr.address_type NOT IN ('program')\n        GROUP BY other_addr.id\n        ORDER BY shared_tx_count DESC\n        LIMIT 25;\n        \n        -- Programs Used\n        SELECT \n            prog.address,\n            COALESCE(prog.label, NULL) as label,\n            COUNT(DISTINCT t.id) as tx_count\n        FROM transaction_participants tp\n        JOIN transactions t ON tp.tx_id = t.id\n        JOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.role = 'program'\n        JOIN addresses prog ON tp2.address_id = prog.id\n        WHERE tp.address_id = v_address_id\n        GROUP BY prog.id\n        ORDER BY tx_count DESC\n        LIMIT 15;\n    END IF;\nEND //\n\nDELIMITER ;\n\n-- Test it\nCALL sp_address_activity('Hnxj8Fd9wMaYRWRW6YJP6zJF7nh3QTzM3KufGEuefD8v');\nEOF)",
      "Bash(1 <<'EOF'\n-- Check if we need a covering index for the common lookup pattern\n-- The procedure does: SELECT id INTO v_address_id FROM addresses WHERE address = v_address\n\n-- Current unique index on address should cover this, but let's verify the query plan\nEXPLAIN SELECT id FROM addresses WHERE address = 'So11111111111111111111111111111111111111112';\n\n-- For sp_address_activity, check the JOIN patterns\nEXPLAIN SELECT tp.role, COUNT(*) \nFROM transaction_participants tp \nWHERE tp.address_id = 1256 \nGROUP BY tp.role;\n\n-- Check counterparty query\nEXPLAIN SELECT COUNT(DISTINCT t.id)\nFROM transaction_participants tp\nJOIN transactions t ON tp.tx_id = t.id\nJOIN transaction_participants tp2 ON tp2.tx_id = t.id AND tp2.address_id != tp.address_id\nWHERE tp.address_id = 1256\nLIMIT 1;\nEOF)",
      "Bash(1 <<'EOF'\n-- Recommended indexes for performance optimization\n\n-- 1. Composite index for transaction_participants covering common queries\n-- This helps the sp_address_activity queries that filter by address_id and group by role\n-- Current idx_address_role already covers (address_id, role)\n\n-- 2. Check if we need an index on transaction_participants for tx_id lookups\nEXPLAIN SELECT * FROM transaction_participants WHERE tx_id = 1669;\n\n-- 3. For sp_build_all_addresses, check if transactions table scan is optimal\nEXPLAIN SELECT id, account_keys, programs, pre_balances, post_balances, \n       pre_token_balances, post_token_balances, inner_instructions, \n       address_table_lookups, transaction_json \nFROM transactions LIMIT 10;\n\n-- 4. Check index statistics\nSELECT \n    TABLE_NAME,\n    INDEX_NAME,\n    COLUMN_NAME,\n    CARDINALITY,\n    ROUND(CARDINALITY / (SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA = 't16o_db' AND TABLE_NAME = STATISTICS.TABLE_NAME), 2) as selectivity\nFROM information_schema.STATISTICS \nWHERE TABLE_SCHEMA = 't16o_db'\nORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;\nEOF)",
      "Bash(1 <<'EOF'\n-- Update table statistics\nANALYZE TABLE addresses;\nANALYZE TABLE transactions;\nANALYZE TABLE transaction_participants;\n\n-- Now check cardinality again\nSELECT \n    TABLE_NAME,\n    INDEX_NAME,\n    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns,\n    MAX(CARDINALITY) as cardinality\nFROM information_schema.STATISTICS \nWHERE TABLE_SCHEMA = 't16o_db'\n  AND TABLE_NAME IN ('addresses', 'transactions', 'transaction_participants')\nGROUP BY TABLE_NAME, INDEX_NAME\nORDER BY TABLE_NAME, INDEX_NAME;\nEOF)",
      "Bash(1 <<'EOF'\n-- =====================================================\n-- INDEX OPTIMIZATION SCRIPT\n-- =====================================================\n\n-- 1. REDUNDANT INDEX: idx_address is redundant since idx_address_role starts with address_id\n--    DROP INDEX idx_address ON transaction_participants;\n--    (Keeping for now as it's a covering index for address_id-only lookups)\n\n-- 2. ADD: Composite index for token transfer queries (address + token_mint)\n--    This helps queries like \"what tokens has this wallet traded\"\nCREATE INDEX IF NOT EXISTS idx_address_token ON transaction_participants (address_id, token_mint_id);\n\n-- 3. ADD: Index for role-based queries (finding all senders/receivers)\nCREATE INDEX IF NOT EXISTS idx_role ON transaction_participants (role);\n\n-- 4. ADD: Covering index for sp_address_activity token summary\n--    Covers: WHERE address_id = ? AND token_mint_id IS NOT NULL GROUP BY token_mint_id\nCREATE INDEX IF NOT EXISTS idx_address_mint_role ON transaction_participants (address_id, token_mint_id, role, amount);\n\n-- 5. For sp_build_all_addresses: The cursor query would benefit from no additional indexes\n--    since it's a full table scan (intentional)\n\n-- Verify new indexes\nSHOW INDEX FROM transaction_participants WHERE Key_name LIKE 'idx_%';\nEOF)",
      "Bash(1 <<'EOF'\n-- =====================================================\n-- INDEX OPTIMIZATION SCRIPT\n-- =====================================================\n\n-- 1. Drop redundant idx_address (covered by idx_address_role)\nDROP INDEX IF EXISTS idx_address ON transaction_participants;\n\n-- 2. ADD: Composite index for token transfer queries (address + token_mint)\nALTER TABLE transaction_participants ADD INDEX idx_address_token (address_id, token_mint_id);\n\n-- 3. ADD: Index for role-based queries\nALTER TABLE transaction_participants ADD INDEX idx_role (role);\n\n-- 4. ADD: Covering index for token summary in sp_address_activity\nALTER TABLE transaction_participants ADD INDEX idx_address_mint_role_amt (address_id, token_mint_id, role, amount);\n\n-- Show all indexes now\nSELECT \n    INDEX_NAME,\n    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns\nFROM information_schema.STATISTICS \nWHERE TABLE_SCHEMA = 't16o_db' AND TABLE_NAME = 'transaction_participants'\nGROUP BY INDEX_NAME\nORDER BY INDEX_NAME;\nEOF)",
      "Bash(1 <<'EOF'\n-- =====================================================\n-- INDEX OPTIMIZATION SCRIPT\n-- =====================================================\n\n-- 1. Drop redundant idx_address (covered by idx_address_role)\nDROP INDEX idx_address ON transaction_participants;\n\n-- 2. ADD: Composite index for token transfer queries (address + token_mint)\nCREATE INDEX idx_address_token ON transaction_participants (address_id, token_mint_id);\n\n-- 3. ADD: Index for role-based queries\nCREATE INDEX idx_role ON transaction_participants (role);\n\n-- 4. ADD: Covering index for token summary in sp_address_activity\nCREATE INDEX idx_address_mint_role_amt ON transaction_participants (address_id, token_mint_id, role, amount);\n\n-- Show all indexes now\nSELECT \n    INDEX_NAME,\n    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns,\n    MAX(CARDINALITY) as cardinality\nFROM information_schema.STATISTICS \nWHERE TABLE_SCHEMA = 't16o_db' AND TABLE_NAME = 'transaction_participants'\nGROUP BY INDEX_NAME\nORDER BY INDEX_NAME;\nEOF)",
      "Bash(1 <<'EOF'\n-- Test query plans after optimization\n\n-- 1. Token summary query (should use idx_address_mint_role_amt as covering index)\nEXPLAIN SELECT \n    token_mint_id,\n    SUM(CASE WHEN role = 'sender' THEN amount ELSE 0 END) as sent,\n    SUM(CASE WHEN role = 'receiver' THEN amount ELSE 0 END) as received\nFROM transaction_participants\nWHERE address_id = 1256 AND token_mint_id IS NOT NULL\nGROUP BY token_mint_id;\n\n-- 2. Role-based query (should use idx_role)\nEXPLAIN SELECT COUNT(*) FROM transaction_participants WHERE role = 'sender';\n\n-- 3. Address + token query (should use idx_address_token)\nEXPLAIN SELECT * FROM transaction_participants WHERE address_id = 1256 AND token_mint_id = 5;\nEOF)"
    ],
    "deny": [],
    "ask": []
  }
}
