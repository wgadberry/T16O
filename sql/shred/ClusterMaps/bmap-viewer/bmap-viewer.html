<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BMap Token State Viewer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --bg-input: #0f3460;
            --text-primary: #eee;
            --text-secondary: #aaa;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --success: #4ade80;
            --warning: #fbbf24;
            --border: #333;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 2800px; margin: 0 auto; }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--accent);
        }

        /* Query Form */
        .query-form {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .form-group label { color: var(--text-secondary); font-size: 12px; text-transform: uppercase; }

        .form-group input {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
        }

        .form-group input:focus { outline: none; border-color: var(--accent); }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn:hover { background: var(--accent-hover); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Edge Type Badges */
        .edge-types {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .edge-type {
            background: var(--accent);
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 11px;
        }

        /* Swap category - green/red */
        .edge-type.swap_in { background: #22c55e; }
        .edge-type.swap_out { background: #ef4444; }
        /* Transfer category - blue */
        .edge-type.spl_transfer { background: #3b82f6; }
        .edge-type.sol_transfer { background: #60a5fa; }
        .edge-type.wallet_funded { background: #a855f7; }
        .edge-type.funded_by { background: #a855f7; }
        /* Account category - cyan */
        .edge-type.create_ata { background: #06b6d4; }
        .edge-type.close_ata { background: #0891b2; }
        /* Fee category - gray */
        .edge-type.fee { background: #6b7280; }
        .edge-type.priority_fee { background: #4b5563; }
        .edge-type.protocol_fee { background: #9ca3af; }
        /* Lending category - orange */
        .edge-type.lend_deposit { background: #f97316; }
        .edge-type.lend_withdraw { background: #ea580c; }
        .edge-type.borrow { background: #fb923c; }
        .edge-type.repay { background: #fdba74; }
        .edge-type.liquidation { background: #c2410c; }
        /* Staking category - amber */
        .edge-type.stake { background: #f59e0b; }
        .edge-type.unstake { background: #d97706; }
        .edge-type.stake_reward { background: #fbbf24; }
        /* Liquidity category - teal */
        .edge-type.add_liquidity { background: #14b8a6; }
        .edge-type.remove_liquidity { background: #0d9488; }
        .edge-type.farm_deposit { background: #2dd4bf; }
        .edge-type.farm_withdraw { background: #5eead4; }
        .edge-type.lp_reward { background: #99f6e4; color: #0f172a; }
        /* Bridge category - indigo */
        .edge-type.bridge_in { background: #6366f1; }
        .edge-type.bridge_out { background: #818cf8; }
        /* Perp category - rose */
        .edge-type.perp_open { background: #f43f5e; }
        .edge-type.perp_close { background: #fb7185; }
        .edge-type.perp_deposit { background: #e11d48; }
        .edge-type.perp_withdraw { background: #be123c; }
        .edge-type.margin_deposit { background: #fda4af; }
        .edge-type.margin_withdraw { background: #fecdd3; color: #0f172a; }
        .edge-type.margin_call { background: #9f1239; }
        .edge-type.perp_liquidation { background: #881337; }
        .edge-type.funding_payment { background: #fecaca; color: #0f172a; }
        .edge-type.pnl_settlement { background: #fca5a5; color: #0f172a; }
        /* NFT category - pink */
        .edge-type.nft_mint { background: #ec4899; }
        .edge-type.nft_sale { background: #f472b6; }
        .edge-type.nft_transfer { background: #f9a8d4; color: #0f172a; }
        /* Other category - slate */
        .edge-type.mint { background: #22d3ee; }
        .edge-type.burn { background: #ff6b6b; }
        .edge-type.airdrop { background: #a78bfa; }
        .edge-type.unknown { background: #475569; }

        /* Token Info */
        .token-info {
            background: var(--bg-card);
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .token-info .symbol { font-size: 24px; font-weight: bold; color: var(--accent); }
        .token-info .mint { font-family: monospace; font-size: 12px; color: var(--text-secondary); }

        /* Data Grid */
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) { .data-grid { grid-template-columns: 1fr; } }

        .data-section {
            background: var(--bg-card);
            border-radius: 10px;
            overflow: hidden;
        }

        .data-section h3 {
            background: var(--bg-input);
            padding: 12px 20px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Nodes */
        .node {
            background: var(--bg-input);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent);
        }

        .node .address {
            font-family: monospace;
            font-size: 11px;
            color: var(--accent);
            word-break: break-all;
        }

        .node .label { color: var(--text-secondary); font-size: 12px; margin-top: 5px; }

        .node .stats {
            display: flex;
            gap: 15px;
            margin-top: 8px;
            font-size: 13px;
        }

        .node .stat-value { color: var(--success); font-weight: bold; }

        /* Edges */
        .edge {
            background: var(--bg-input);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .edge .flow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .edge .addr {
            font-family: monospace;
            font-size: 10px;
            color: var(--accent);
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .edge .arrow { color: var(--warning); font-size: 16px; }
        .edge .amount { color: var(--success); font-weight: bold; }

        .edge .meta {
            display: flex;
            gap: 10px;
            color: var(--text-secondary);
            font-size: 11px;
        }

        /* Error */
        .error {
            background: #7f1d1d;
            color: #fca5a5;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* Bubble Map */
        .bubble-map-container {
            background: var(--bg-card);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .bubble-map-header {
            background: var(--bg-input);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bubble-map-header h3 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
        }

        .bubble-map-controls {
            display: flex;
            gap: 10px;
        }

        .bubble-map-controls button {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .bubble-map-controls button:hover {
            border-color: var(--accent);
        }

        #bubble-map {
            width: 100%;
            height: 1000px;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0d0d1a 100%);
        }

        #bubble-map svg {
            width: 100%;
            height: 100%;
        }

        .node-circle {
            cursor: pointer;
            transition: stroke-width 0.2s;
        }

        .node-circle:hover {
            stroke-width: 3px;
        }

        .node-label {
            font-size: 10px;
            fill: var(--text-secondary);
            pointer-events: none;
            text-anchor: middle;
        }

        .edge-line {
            stroke-opacity: 0.6;
            fill: none;
        }

        .edge-arrow {
            fill: var(--text-secondary);
        }

        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .tooltip .address {
            font-family: monospace;
            color: var(--accent);
            word-break: break-all;
            margin-bottom: 8px;
        }

        .tooltip .stats {
            color: var(--text-secondary);
        }

        .tooltip .stats span {
            color: var(--success);
        }

        .legend {
            display: flex;
            gap: 15px;
            padding: 10px 20px;
            background: var(--bg-input);
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Timeline Slider */
        .timeline-container {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .timeline-header h3 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            color: var(--text-secondary);
        }

        .timeline-stats {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .timeline-stats span {
            color: var(--accent);
        }

        .timeline-slider-wrap {
            position: relative;
            padding: 10px 0;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .timeline-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-input);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .timeline-current {
            text-align: center;
            margin-top: 10px;
            font-size: 13px;
        }

        .timeline-current .time {
            color: var(--accent);
            font-weight: bold;
        }

        .timeline-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .timeline-buttons button {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .timeline-buttons button:hover {
            border-color: var(--accent);
            background: var(--bg-card);
        }

        .timeline-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Compact Current TX Bar */
        .current-tx-bar {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 12px 20px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .current-tx-bar .sig-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .current-tx-bar .signature {
            font-family: monospace;
            font-size: 11px;
            color: var(--accent);
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .current-tx-bar .time {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Collapsible Section */
        .collapsible-section {
            background: var(--bg-card);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .collapsible-header {
            background: var(--bg-input);
            padding: 12px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .collapsible-header:hover {
            background: #1a4a7a;
        }

        .collapsible-header h3 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapsible-header .toggle-icon {
            transition: transform 0.3s;
            font-size: 12px;
        }

        .collapsible-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            padding: 15px 20px;
            display: block;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .nav-compact {
            display: flex;
            gap: 20px;
        }

        .nav-compact .nav-list {
            flex: 1;
        }

        .nav-compact .nav-list h4 {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .nav-compact .nav-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 6px;
            cursor: pointer;
            font-size: 11px;
        }

        .nav-compact .nav-item:hover {
            border-color: var(--accent);
        }

        /* Funder Filter Panel */
        .funder-panel { background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 10px; max-height: 300px; overflow-y: auto; }
        .funder-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        .funder-panel-header h4 { font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin: 0; }
        .funder-clear-btn { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .funder-clear-btn:hover { border-color: var(--accent); color: var(--accent); }
        .funder-clear-btn.hidden { display: none; }
        .funder-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; margin-bottom: 6px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .funder-item:hover { border-color: var(--accent); background: rgba(233, 69, 96, 0.1); }
        .funder-item.active { border-color: var(--accent); background: rgba(233, 69, 96, 0.2); }
        .funder-dot { width: 10px; height: 10px; border-radius: 50%; background: #a855f7; flex-shrink: 0; }
        .funder-address { font-family: monospace; font-size: 11px; color: var(--accent); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .funder-count { background: var(--bg-input); padding: 2px 8px; border-radius: 10px; font-size: 10px; color: var(--text-secondary); }
        .funder-empty { color: var(--text-secondary); font-size: 12px; text-align: center; padding: 20px; }
        .bubble-map-layout { display: flex; gap: 0; }
        .bubble-map-main { flex: 1; min-width: 0; }
        .bubble-map-sidebar { width: 280px; flex-shrink: 0; background: var(--bg-card); border-left: 1px solid var(--border); }
        @media (max-width: 900px) { .bubble-map-layout { flex-direction: column; } .bubble-map-sidebar { width: 100%; border-left: none; border-top: 1px solid var(--border); } }
        .filter-active-badge { background: var(--accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px; margin-left: 10px; }

        /* Main Layout with Left Sidebar */
        .main-layout { display: flex; gap: 15px; }
        .left-sidebar { width: 280px; flex-shrink: 0; display: flex; flex-direction: column; gap: 15px; }
        .main-content { flex: 1; min-width: 0; }
        @media (max-width: 1100px) { .main-layout { flex-direction: column; } .left-sidebar { width: 100%; } }
        
        /* Compact Query Form for Sidebar */
        .query-form-compact { background: var(--bg-card); padding: 15px; border-radius: 10px; }
        .query-form-compact .form-group { margin-bottom: 10px; }
        .query-form-compact .form-group:last-child { margin-bottom: 0; }
        .query-form-compact input, .query-form-compact select { width: 100%; padding: 8px 10px; font-size: 12px; }
        .query-form-compact .btn { width: 100%; padding: 10px; font-size: 12px; }
        
        /* Token Info Sidebar Card */
        .token-sidebar { background: var(--bg-card); padding: 15px; border-radius: 10px; }
        .token-sidebar .symbol { font-size: 20px; font-weight: bold; color: var(--accent); margin-bottom: 8px; }
        .token-sidebar .info-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 11px; }
        .token-sidebar .info-row:last-child { border-bottom: none; }
        .token-sidebar .info-label { color: var(--text-secondary); }
        .token-sidebar .info-value { color: var(--text-primary); font-family: monospace; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        
        /* Current TX Sidebar Card */
        .tx-sidebar { background: var(--bg-card); padding: 15px; border-radius: 10px; }
        .tx-sidebar h4 { font-size: 11px; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 10px; }
        .tx-sidebar .sig { font-family: monospace; font-size: 10px; color: var(--accent); word-break: break-all; margin-bottom: 8px; }
        .tx-sidebar .time { font-size: 11px; color: var(--text-secondary); }

        /* Related Tokens */
        .related-tokens { background: var(--bg-card); padding: 15px; border-radius: 10px; }
        .related-tokens h4 { font-size: 11px; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 10px; }
        .related-token-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
        .related-token-item:last-child { border-bottom: none; }
        .related-token-item:hover { background: rgba(255,255,255,0.05); margin: 0 -8px; padding-left: 8px; padding-right: 8px; border-radius: 4px; }
        .related-token-item .token-info { display: flex; flex-direction: column; gap: 2px; }
        .related-token-item .token-symbol { font-weight: bold; color: var(--accent); font-size: 12px; }
        .related-token-item .token-name { font-size: 10px; color: var(--text-secondary); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .related-token-item .token-stats { text-align: right; font-size: 10px; color: var(--text-secondary); }
        .related-token-item .swap-count { color: #22c55e; font-weight: 500; }
        
        /* Fetch Status Toast */
        .fetch-toast { position: fixed; bottom: 20px; right: 20px; background: var(--bg-card); border: 1px solid var(--accent); padding: 15px 20px; border-radius: 8px; z-index: 2000; display: none; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .fetch-toast.show { display: block; }
        .fetch-toast.success { border-color: var(--success); }
        .fetch-toast.error { border-color: #ef4444; }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="margin-bottom: 15px;">BMap Token State Viewer</h1>
        
        <div class="main-layout">
            <!-- Left Sidebar -->
            <div class="left-sidebar">
                <!-- Query Form -->
                <div class="query-form-compact">
                    <div class="form-group">
                        <label>Token Symbol</label>
                        <input type="text" id="token_symbol" placeholder="e.g. BONK">
                    </div>
                    <div class="form-group">
                        <label>Mint Address</label>
                        <input type="text" id="mint_address" placeholder="Mint address...">
                    </div>
                    <div class="form-group">
                        <label>TX Signature</label>
                        <input type="text" id="signature" placeholder="Paste signature..." style="font-family: monospace; font-size: 10px;">
                    </div>
                    <div class="form-group">
                        <label>TX Window</label>
                        <select id="tx_limit" style="background: var(--bg-input); border: 1px solid var(--border); color: var(--text-primary); padding: 8px 10px; border-radius: 5px; font-size: 12px; width: 100%;">
                            <option value="1">Single TX</option>
                            <option value="10" selected>10 (5+5)</option>
                            <option value="20">20 (10+10)</option>
                            <option value="50">50 (25+25)</option>
                            <option value="100">100 (50+50)</option>
                        </select>
                    </div>
                    <input type="hidden" id="token_name">
                    <input type="hidden" id="block_time">
                    <button class="btn" onclick="fetchData()">Load Token</button>
                </div>
                
                <!-- Token Info (populated dynamically) -->
                <div id="sidebar-token-info"></div>
                
                <!-- Current TX Info (populated dynamically) -->
                <div id="sidebar-tx-info"></div>

                <!-- Related Tokens (populated dynamically) -->
                <div id="sidebar-related-tokens"></div>
            </div>
            
            <!-- Main Content -->
            <div class="main-content">
                <div id="results"></div>
            </div>
        </div>
        
        <!-- Fetch Toast -->
        <div id="fetch-toast" class="fetch-toast"></div>
    </div>

    <script>
        const API_BASE = '/api/bmap';
        let currentData = null;

        async function fetchData(params = null) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">Loading</div>';

            // Reset timeline if loading fresh (not navigating)
            const isNavigation = params && (params.signature || params.block_time);
            if (!isNavigation) {
                timelineData = { minTime: 0, maxTime: 0, currentTime: 0, txCount: 0 };
                // Reset filters only on fresh load
                activeTokenFilters = {};
                activeCategoryFilters = {
                    swap: true, transfer: true, account: true, fee: true,
                    lending: true, staking: true, liquidity: true, bridge: true,
                    perp: true, nft: true, other: true
                };
                showFundedBy = true;
            }

            // Build query params
            if (!params) {
                params = {
                    token_name: document.getElementById('token_name').value || undefined,
                    token_symbol: document.getElementById('token_symbol').value || undefined,
                    mint_address: document.getElementById('mint_address').value || undefined,
                    signature: document.getElementById('signature').value || undefined,
                    block_time: document.getElementById('block_time').value || undefined,
                    tx_limit: document.getElementById('tx_limit').value || undefined
                };

                // Detect signature-only mode (signature provided, no token identifiers)
                signatureOnlyMode = !!(params.signature && !params.mint_address && !params.token_symbol && !params.token_name);
            } else {
                // Add tx_limit to navigation params
                params.tx_limit = document.getElementById('tx_limit').value || undefined;

                // Check if this is signature-only navigation
                if (params.signature && !params.mint_address && !params.token_symbol) {
                    signatureOnlyMode = true;
                }
            }

            // Remove undefined params
            Object.keys(params).forEach(k => params[k] === undefined && delete params[k]);

            const queryString = new URLSearchParams(params).toString();

            try {
                const response = await fetch(`${API_BASE}?${queryString}`);
                const data = await response.json();
                currentData = data;
                renderResults(data);
            } catch (error) {
                resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        function navigateTo(signature) {
            // Update signature input and fetch
            document.getElementById('signature').value = signature;

            if (signatureOnlyMode) {
                // Signature-only mode - just pass signature to show all tokens
                fetchData({ signature });
            } else {
                // Normal token navigation - use form values
                const mintFromForm = document.getElementById('mint_address').value;
                const symbolFromForm = document.getElementById('token_symbol').value;
                fetchData({
                    signature,
                    mint_address: mintFromForm || undefined,
                    token_symbol: (!mintFromForm && symbolFromForm) ? symbolFromForm : undefined
                });
            }
        }

        function loadToken(mintAddress) {
            // Clear other inputs and load new token by mint address
            document.getElementById('token_symbol').value = '';
            document.getElementById('token_name').value = '';
            document.getElementById('mint_address').value = mintAddress;
            document.getElementById('signature').value = '';
            document.getElementById('block_time').value = '';
            fetchData({ mint_address: mintAddress });
        }

        function renderResults(data) {
            const resultsDiv = document.getElementById('results');

            if (data.result?.error) {
                resultsDiv.innerHTML = `<div class="error">${data.result.error}</div>`;
                return;
            }

            const { txs, token, nodes, edges } = data.result;

            // Populate mint_address field if we have it (for consistent navigation)
            // But NOT in signature-only mode (we want to keep showing all tokens)
            if (token?.mint && !signatureOnlyMode && !document.getElementById('mint_address').value) {
                document.getElementById('mint_address').value = token.mint;
            }

            // Update sidebar token info
            const sidebarToken = document.getElementById('sidebar-token-info');
            if (sidebarToken && token) {
                sidebarToken.innerHTML = `
                    <div class="token-sidebar">
                        <div class="symbol">${token.symbol || 'Unknown'}</div>
                        <div class="info-row">
                            <span class="info-label">Mint</span>
                            <span class="info-value" title="${token.mint}">${token.mint.slice(0,8)}...${token.mint.slice(-6)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Holders</span>
                            <span class="info-value">${(nodes || []).length}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Edges</span>
                            <span class="info-value">${(edges || []).length}</span>
                        </div>
                    </div>
                `;
            }

            // Update sidebar TX info
            const sidebarTx = document.getElementById('sidebar-tx-info');
            if (sidebarTx && txs) {
                sidebarTx.innerHTML = `
                    <div class="tx-sidebar">
                        <h4>Current Transaction</h4>
                        <div class="sig">${txs.signature}</div>
                        <div class="time">${txs.block_time_utc}</div>
                        <div class="edge-types" style="margin-top: 8px; justify-content: flex-start;">
                            ${(txs.edge_types || []).map(t =>
                                `<span class="edge-type ${t}">${t}</span>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            // Update related tokens
            const relatedTokens = data.result.related_tokens || [];
            const sidebarRelated = document.getElementById('sidebar-related-tokens');
            if (sidebarRelated) {
                if (relatedTokens.length > 0) {
                    sidebarRelated.innerHTML = `
                        <div class="related-tokens">
                            <h4>Tokens in Transactions</h4>
                            ${relatedTokens.map(rt => `
                                <div class="related-token-item" onclick="loadToken('${rt.mint}')" title="Click to view ${rt.symbol}">
                                    <div class="token-info">
                                        <span class="token-symbol">${rt.symbol || 'Unknown'}</span>
                                        <span class="token-name">${rt.name || rt.mint.slice(0,12) + '...'}</span>
                                    </div>
                                    <div class="token-stats">
                                        <span class="swap-count">${rt.swap_count} swaps</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    sidebarRelated.innerHTML = '';
                }
            }

            let html = '';

            // Timeline Slider (visible if we have timeline data)
            const timelineVisible = timelineData.minTime > 0 ? 'block' : 'none';
            html += `
                <div class="timeline-container" id="timeline-section" style="display: ${timelineVisible};">
                    <div class="timeline-header">
                        <h3>Timeline</h3>
                        <div class="timeline-stats">
                            <span id="timeline-tx-count">0</span> transactions
                        </div>
                    </div>
                    <div class="timeline-slider-wrap">
                        <div class="timeline-labels">
                            <span id="timeline-min-label">--</span>
                            <span id="timeline-max-label">--</span>
                        </div>
                        <input type="range" class="timeline-slider" id="timeline-slider"
                            min="0" max="100" value="50">
                    </div>
                    <div class="timeline-current">
                        Current: <span class="time" id="timeline-current-time">--</span>
                    </div>
                    <div class="timeline-buttons">
                        <button onclick="timelineJump('start')">⏮ First</button>
                        <button onclick="timelineStep(-1)">◀ Prev</button>
                        <button onclick="timelineStep(1)">Next ▶</button>
                        <button onclick="timelineJump('end')">Last ⏭</button>
                    </div>
                </div>
            `;

            // Bubble Map with Funder Sidebar
            html += `
                <div class="bubble-map-container">
                    <div class="bubble-map-header">
                        <h3>Bubble Map<span id="filter-badge" class="filter-active-badge" style="display:none;">Filtered</span></h3>
                        <div class="bubble-map-controls">
                            <div class="edge-type-filters" style="display: flex; gap: 8px; margin-right: 15px; flex-wrap: wrap;">
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-swap" ${activeCategoryFilters.swap ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type swap_in">swap</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-transfer" ${activeCategoryFilters.transfer ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type spl_transfer">transfer</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-account" ${activeCategoryFilters.account ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type create_ata">account</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-lending" ${activeCategoryFilters.lending ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type lend_deposit">lending</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-staking" ${activeCategoryFilters.staking ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type stake">staking</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-liquidity" ${activeCategoryFilters.liquidity ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type add_liquidity">liquidity</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-cat-other" ${activeCategoryFilters.other ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type burn">other</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; font-size: 10px;">
                                    <input type="checkbox" id="filter-funded_by" ${showFundedBy ? 'checked' : ''} onchange="applyEdgeFilters()">
                                    <span class="edge-type funded_by">funders</span>
                                </label>
                            </div>
                            <button onclick="resetZoom()">Reset Zoom</button>
                            <button onclick="toggleLabels()">Toggle Labels</button>
                        </div>
                    </div>
                    <div class="bubble-map-layout">
                        <div class="bubble-map-main">
                            <div id="bubble-map"></div>
                        </div>
                        <div class="bubble-map-sidebar">
                            <div class="funder-panel">
                                <div class="funder-panel-header">
                                    <h4>Tokens</h4>
                                    <button class="funder-clear-btn hidden" id="token-clear-btn" onclick="clearTokenFilter()">Clear</button>
                                </div>
                                <div id="token-filter-list"></div>
                            </div>
                            <div class="funder-panel" style="margin-top: 10px;">
                                <div class="funder-panel-header">
                                    <h4>Funders</h4>
                                    <button class="funder-clear-btn hidden" id="funder-clear-btn" onclick="clearFunderFilter()">Clear</button>
                                </div>
                                <div id="funder-list"></div>
                            </div>
                        </div>
                    </div>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background: #e94560;"></div> High Balance</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div> Medium Balance</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div> Low Balance</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #666;"></div> Zero/Sold (Pools, ATAs)</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #a855f7;"></div> Funded By Link</div>
                    </div>
                </div>
            `;

            // Collapsible Prev/Next Navigation
            if (txs) {
                const prevCount = (txs.prev || []).length;
                const nextCount = (txs.next || []).length;
                html += `
                    <div class="collapsible-section">
                        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
                            <h3>
                                <span class="toggle-icon">▼</span>
                                Transaction Navigation
                                <span style="font-weight: normal; color: var(--text-secondary);">(${prevCount} prev / ${nextCount} next)</span>
                            </h3>
                        </div>
                        <div class="collapsible-content collapsed">
                            <div class="nav-compact">
                                <div class="nav-list">
                                    <h4>← Previous (${prevCount})</h4>
                                    ${(txs.prev || []).map(p => `
                                        <div class="nav-item" onclick="navigateTo('${p.signature}')">
                                            <div class="sig" style="font-family: monospace; color: var(--accent);">${p.signature.slice(0, 20)}...</div>
                                            <div class="time" style="color: var(--text-secondary); font-size: 10px;">${p.block_time_utc}</div>
                                            <div class="edge-types" style="justify-content: flex-start; margin-top: 4px;">
                                                ${(p.edge_types || []).map(t =>
                                                    `<span class="edge-type ${t}">${t}</span>`
                                                ).join('')}
                                            </div>
                                        </div>
                                    `).join('')}
                                    ${prevCount === 0 ? '<div style="color: var(--text-secondary); font-size: 12px;">No previous transactions</div>' : ''}
                                </div>
                                <div class="nav-list">
                                    <h4>Next → (${nextCount})</h4>
                                    ${(txs.next || []).map(n => `
                                        <div class="nav-item" onclick="navigateTo('${n.signature}')">
                                            <div class="sig" style="font-family: monospace; color: var(--accent);">${n.signature.slice(0, 20)}...</div>
                                            <div class="time" style="color: var(--text-secondary); font-size: 10px;">${n.block_time_utc}</div>
                                            <div class="edge-types" style="justify-content: flex-start; margin-top: 4px;">
                                                ${(n.edge_types || []).map(t =>
                                                    `<span class="edge-type ${t}">${t}</span>`
                                                ).join('')}
                                            </div>
                                        </div>
                                    `).join('')}
                                    ${nextCount === 0 ? '<div style="color: var(--text-secondary); font-size: 12px;">No next transactions</div>' : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Data Grid
            html += '<div class="data-grid">';

            // Nodes
            html += `
                <div class="data-section">
                    <h3>Nodes (${(nodes || []).length} holders)</h3>
                    <div class="data-content">
                        ${(nodes || []).map(n => `
                            <div class="node">
                                <div class="address">${n.address}</div>
                                <div class="label">${n.label || 'Unknown'}</div>
                                <div class="stats">
                                    <span>Balance: <span class="stat-value">${formatNumber(n.balance)}</span></span>
                                    <span>SOL: <span class="stat-value">${n.sol_balance?.toFixed(4) || '0'}</span></span>
                                </div>
                                ${n.funded_by ? `<div class="label" style="margin-top: 5px;">Funded by: ${n.funded_by.slice(0, 20)}...</div>` : ''}
                            </div>
                        `).join('')}
                        ${(nodes || []).length === 0 ? '<div style="color: var(--text-secondary);">No nodes</div>' : ''}
                    </div>
                </div>
            `;

            // Edges
            html += `
                <div class="data-section">
                    <h3>Edges (${(edges || []).length} transfers)</h3>
                    <div class="data-content">
                        ${(edges || []).map(e => `
                            <div class="edge">
                                <div class="flow">
                                    <span class="addr" title="${e.source}">${e.source.slice(0, 12)}...</span>
                                    <span class="arrow">→</span>
                                    <span class="addr" title="${e.target}">${e.target.slice(0, 12)}...</span>
                                    <span class="amount">${formatNumber(e.amount)}</span>
                                    <span class="edge-type ${e.type}">${e.type}</span>
                                    ${e.dex ? `<span style="color: var(--warning); font-size: 10px;">${e.dex}</span>` : ''}
                                </div>
                                <div class="meta">
                                    <span>${e.block_time_utc}</span>
                                    <span title="${e.signature}">${e.signature.slice(0, 16)}...</span>
                                    ${e.ins_index !== null ? `<span style="color: var(--text-secondary);">#${e.ins_index}</span>` : ''}
                                </div>
                                ${e.pool || e.program ? `
                                <div class="meta" style="margin-top: 4px;">
                                    ${e.pool ? `<span title="${e.pool}">Pool: ${e.pool.slice(0, 8)}...</span>` : ''}
                                    ${e.program ? `<span title="${e.program}">Prog: ${e.program.slice(0, 8)}...</span>` : ''}
                                </div>
                                ` : ''}
                            </div>
                        `).join('')}
                        ${(edges || []).length === 0 ? '<div style="color: var(--text-secondary);">No edges</div>' : ''}
                    </div>
                </div>
            `;

            html += '</div>';

            resultsDiv.innerHTML = html;

            // Store nodes/edges and render bubble map
            allNodes = nodes;
            allEdges = edges;
            setTimeout(() => {
                renderBubbleMap(nodes, edges);
                renderTokenFilterList(edges);
                renderFunderList(nodes);
                // Apply existing filters if any are set (preserves selections during navigation)
                const hasTokenFilters = Object.values(activeTokenFilters).some(v => v === false);
                const hasCategoryFilters = Object.values(activeCategoryFilters).some(v => v === false);
                if (hasTokenFilters || hasCategoryFilters || !showFundedBy) {
                    applyAllFilters();
                }
            }, 100);

            // Initialize/update timeline
            if (token) {
                if (timelineData.minTime === 0) {
                    // First load - fetch time range
                    initTimeline(token);
                } else {
                    // Restore timeline UI and update position
                    restoreTimelineUI();
                    updateTimelinePosition(txs?.block_time);
                }
            }
        }

        // Bubble Map Variables
        let simulation = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let showLabels = true;
        let currentTransform = d3.zoomIdentity; // Preserve zoom state
        let activeFunder = null; // Currently selected funder for filtering
        let allNodes = null; // Store all nodes for filtering
        let allEdges = null; // Store all edges for filtering
        let signatureOnlyMode = false; // True when loaded by signature only (show all tokens)

        function renderBubbleMap(nodes, edges) {
            const container = document.getElementById('bubble-map');
            if (!container) return;

            // Clear previous
            container.innerHTML = '';
            d3.selectAll('.tooltip').remove(); // Remove old tooltips

            if (!nodes || nodes.length === 0) {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #aaa;">No nodes to display</div>';
                return;
            }

            const width = container.clientWidth;
            const height = 1000;

            // Create node map for lookups
            const nodeMap = new Map(nodes.map(n => [n.address, n]));

            // Calculate balance range for sizing (use absolute value, treat 0/negative as minimum)
            const balances = nodes.map(n => Math.max(0, n.balance || 0));
            const maxBalance = Math.max(...balances, 1); // Ensure at least 1 to avoid domain issues
            const minBalance = 0;

            // Size scale (radius 8-50 based on balance)
            const sizeScale = d3.scaleSqrt()
                .domain([minBalance, maxBalance])
                .range([8, 50]);

            // Color based on balance percentile
            const colorScale = d3.scaleQuantile()
                .domain(balances)
                .range(['#22c55e', '#3b82f6', '#e94560']);

            // Prepare nodes for D3
            const d3Nodes = nodes.map(n => {
                const displayBalance = Math.max(0, n.balance || 0);
                const isZeroBalance = (n.balance || 0) <= 0;
                return {
                    id: n.address,
                    label: n.label || 'wallet',
                    balance: n.balance || 0,
                    displayBalance: displayBalance,
                    isZeroBalance: isZeroBalance,
                    sol_balance: n.sol_balance || 0,
                    funded_by: n.funded_by,
                    radius: sizeScale(displayBalance),
                    color: isZeroBalance ? '#666' : colorScale(displayBalance) // Gray for zero balance
                };
            });

            // Track nodes with close_ata events (self-edges where ATA was closed)
            const closeAtaInfo = new Map(); // address -> { amount, sol returned }
            (edges || []).forEach(e => {
                if (e.type === 'close_ata' && e.source === e.target) {
                    closeAtaInfo.set(e.source, {
                        amount: e.amount,
                        ins_index: e.ins_index
                    });
                }
            });

            // Add close_ata info to d3Nodes
            d3Nodes.forEach(n => {
                if (closeAtaInfo.has(n.id)) {
                    n.closeAta = closeAtaInfo.get(n.id);
                }
            });

            // Prepare edges for D3 - only include edges where both nodes exist
            // Filter out self-edges (like close_ata) since they can't be rendered as lines
            const d3Edges = (edges || [])
                .filter(e => nodeMap.has(e.source) && nodeMap.has(e.target) && e.source !== e.target)
                .map(e => ({
                    source: e.source,
                    target: e.target,
                    amount: e.amount,
                    type: e.type,
                    token_symbol: e.token_symbol,
                    token_name: e.token_name,
                    decimals: e.decimals,
                    from_token_balance: e.from_token_balance,
                    to_token_balance: e.to_token_balance,
                    from_sol_balance: e.from_sol_balance,
                    to_sol_balance: e.to_sol_balance,
                    signature: e.signature,
                    block_time: e.block_time,
                    block_time_utc: e.block_time_utc,
                    dex: e.dex,
                    pool: e.pool,
                    program: e.program,
                    ins_index: e.ins_index,
                    source_label: e.source_label,
                    target_label: e.target_label,
                    pool_label: e.pool_label
                }));

            // Add funded_by edges
            nodes.forEach(n => {
                if (n.funded_by && nodeMap.has(n.funded_by)) {
                    d3Edges.push({
                        source: n.funded_by,
                        target: n.address,
                        amount: 0,
                        type: 'funded_by'
                    });
                }
            });

            // Create SVG
            svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Add zoom
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    currentTransform = event.transform; // Save transform
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Main group for zoom/pan
            g = svg.append('g');

            // Restore previous zoom level
            if (currentTransform !== d3.zoomIdentity) {
                svg.call(zoom.transform, currentTransform);
            }

            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Edge type colors by category
            const edgeColors = {
                // Swap - green/red
                'swap_in': '#22c55e', 'swap_out': '#ef4444',
                // Transfer - blue/purple
                'spl_transfer': '#3b82f6', 'sol_transfer': '#60a5fa', 'wallet_funded': '#a855f7', 'funded_by': '#a855f7',
                // Account - cyan
                'create_ata': '#06b6d4', 'close_ata': '#0891b2',
                // Fee - gray
                'fee': '#6b7280', 'priority_fee': '#4b5563', 'protocol_fee': '#9ca3af',
                // Lending - orange
                'lend_deposit': '#f97316', 'lend_withdraw': '#ea580c', 'borrow': '#fb923c', 'repay': '#fdba74', 'liquidation': '#c2410c',
                // Staking - amber
                'stake': '#f59e0b', 'unstake': '#d97706', 'stake_reward': '#fbbf24',
                // Liquidity - teal
                'add_liquidity': '#14b8a6', 'remove_liquidity': '#0d9488', 'farm_deposit': '#2dd4bf', 'farm_withdraw': '#5eead4', 'lp_reward': '#99f6e4',
                // Bridge - indigo
                'bridge_in': '#6366f1', 'bridge_out': '#818cf8',
                // Perp - rose
                'perp_open': '#f43f5e', 'perp_close': '#fb7185', 'perp_deposit': '#e11d48', 'perp_withdraw': '#be123c',
                'margin_deposit': '#fda4af', 'margin_withdraw': '#fecdd3', 'margin_call': '#9f1239', 'perp_liquidation': '#881337',
                'funding_payment': '#fecaca', 'pnl_settlement': '#fca5a5',
                // NFT - pink
                'nft_mint': '#ec4899', 'nft_sale': '#f472b6', 'nft_transfer': '#f9a8d4',
                // Other
                'mint': '#22d3ee', 'burn': '#ff6b6b', 'airdrop': '#a78bfa', 'unknown': '#475569'
            };

            // Create edges
            const link = g.append('g')
                .selectAll('line')
                .data(d3Edges)
                .join('line')
                .attr('class', 'edge-line')
                .attr('stroke', d => edgeColors[d.type] || '#666')
                .attr('stroke-width', d => ['funded_by', 'fee', 'priority_fee', 'protocol_fee'].includes(d.type) ? 1 : 3)
                .attr('stroke-dasharray', d => ['funded_by', 'create_ata', 'close_ata'].includes(d.type) ? '4,4' : null)
                .style('cursor', d => d.signature ? 'pointer' : 'default')
                .on('mouseover', (event, d) => {
                    if (!d.signature) return;
                    d3.select(event.target).attr('stroke-width', 5);
                    tooltip.transition().duration(200).style('opacity', 1);
                    const tokenSymbol = d.token_symbol || 'Unknown';
                    const tokenName = d.token_name || null;
                    const tokenDisplay = tokenName && tokenName !== tokenSymbol ? `${tokenSymbol} (${tokenName})` : tokenSymbol;
                    const sourceLabel = d.source_label && !['unknown', 'wallet'].includes(d.source_label) ? d.source_label : null;
                    const targetLabel = d.target_label && !['unknown', 'wallet'].includes(d.target_label) ? d.target_label : null;
                    const poolLabel = d.pool_label || null;
                    tooltip.html(`
                        <div style="margin-bottom: 8px;">
                            <span class="edge-type ${d.type}" style="display: inline-block; margin-bottom: 5px;">${d.type}</span>
                            ${d.dex ? `<span style="color: #fbbf24; font-size: 11px; margin-left: 8px;">${d.dex}</span>` : ''}
                        </div>
                        ${sourceLabel || targetLabel ? `
                        <div style="margin-bottom: 8px; font-size: 11px;">
                            ${sourceLabel ? `<div>From: <span style="color: #a855f7;">${sourceLabel}</span></div>` : ''}
                            ${targetLabel ? `<div>To: <span style="color: #22c55e;">${targetLabel}</span></div>` : ''}
                        </div>
                        ` : ''}
                        <div class="stats">
                            Amount: <span style="color: #22c55e; font-weight: bold;">${formatNumber(d.amount)} ${tokenDisplay}</span><br>
                            ${d.from_sol_balance !== null && d.from_sol_balance !== undefined ? `From SOL: <span style="color: #60a5fa;">${d.from_sol_balance.toFixed(6)}</span><br>` : ''}
                            ${d.to_sol_balance !== null && d.to_sol_balance !== undefined ? `To SOL: <span style="color: #60a5fa;">${d.to_sol_balance.toFixed(6)}</span><br>` : ''}
                            Time: ${d.block_time_utc || (d.block_time ? formatTimestamp(d.block_time) : 'N/A')}
                            ${d.ins_index !== null && d.ins_index !== undefined ? `<br>Instruction: <span>#${d.ins_index}</span>` : ''}
                        </div>
                        ${d.pool || d.program || poolLabel ? `
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333; font-size: 10px;">
                            ${poolLabel ? `<div style="margin-bottom: 4px; color: #fbbf24;">${poolLabel}</div>` : ''}
                            ${d.pool ? `<div style="margin-bottom: 4px;">Pool: <span style="color: #e94560;">${d.pool.slice(0,12)}...</span></div>` : ''}
                            ${d.program ? `<div>Program: <span style="color: #3b82f6;">${d.program.slice(0,12)}...</span></div>` : ''}
                        </div>
                        ` : ''}
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                            <div style="color: #aaa; font-size: 10px; margin-bottom: 3px;">Click to navigate:</div>
                            <div class="address" style="font-size: 10px;">${d.signature}</div>
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', (event, d) => {
                    d3.select(event.target).attr('stroke-width', d.type === 'funded_by' ? 1 : 3);
                    tooltip.transition().duration(500).style('opacity', 0);
                })
                .on('click', (event, d) => {
                    if (d.signature) {
                        tooltip.style('opacity', 0);
                        navigateTo(d.signature);
                    }
                });

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(d3Nodes)
                .join('circle')
                .attr('class', 'node-circle')
                .attr('r', d => d.radius)
                .attr('fill', d => d.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', (event, d) => {
                    tooltip.transition().duration(200).style('opacity', 1);
                    const displayName = d.pool_label || d.token_name || null;
                    tooltip.html(`
                        <div class="address">${d.id}</div>
                        ${displayName ? `<div style="color: #fbbf24; font-weight: bold; margin-bottom: 8px;">${displayName}</div>` : ''}
                        <div class="stats">
                            Type: <span style="color: #a855f7;">${d.address_type || d.label}</span><br>
                            Balance: <span>${formatNumber(d.balance)}</span><br>
                            SOL: <span>${d.sol_balance.toFixed(4)}</span>
                            ${d.funded_by ? '<br>Funded by: ' + d.funded_by.slice(0, 20) + '...' : ''}
                            ${d.closeAta ? `<br><span style="color: #0891b2;">ATA Closed: +${d.closeAta.amount.toFixed(6)} SOL</span>` : ''}
                        </div>
                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #333; color: #aaa; font-size: 10px;">
                            Click to fetch wallet transactions
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.transition().duration(500).style('opacity', 0);
                })
                .on('click', (event, d) => {
                    event.stopPropagation();
                    tooltip.style('opacity', 0);
                    fetchWalletTransactions(d.id);
                });

            // Create close_ata badges (small cyan circle with X for nodes that closed an ATA)
            const closeAtaNodes = d3Nodes.filter(d => d.closeAta);
            const badge = g.append('g')
                .selectAll('g')
                .data(closeAtaNodes)
                .join('g')
                .attr('class', 'close-ata-badge')
                .style('cursor', 'pointer')
                .on('mouseover', (event, d) => {
                    tooltip.transition().duration(200).style('opacity', 1);
                    tooltip.html(`
                        <div style="margin-bottom: 5px;">
                            <span class="edge-type close_ata">close_ata</span>
                        </div>
                        <div class="stats">
                            SOL Returned: <span style="color: #0891b2; font-weight: bold;">${d.closeAta.amount.toFixed(6)} SOL</span><br>
                            Instruction: <span>#${d.closeAta.ins_index}</span>
                        </div>
                        <div style="margin-top: 8px; color: #aaa; font-size: 10px;">
                            Token account was closed, rent returned
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.transition().duration(500).style('opacity', 0);
                });

            // Badge background circle
            badge.append('circle')
                .attr('r', 8)
                .attr('fill', '#0891b2')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);

            // Badge X symbol
            badge.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('fill', '#fff')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .text('X');

            // Create labels
            const label = g.append('g')
                .selectAll('text')
                .data(d3Nodes)
                .join('text')
                .attr('class', 'node-label')
                .text(d => d.id.slice(0, 6) + '...')
                .attr('dy', d => d.radius + 12)
                .style('display', showLabels ? 'block' : 'none');

            // Force simulation
            simulation = d3.forceSimulation(d3Nodes)
                .force('link', d3.forceLink(d3Edges).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 5))
                .on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);

                    // Position badges at top-right of node
                    badge
                        .attr('transform', d => `translate(${d.x + d.radius * 0.7}, ${d.y - d.radius * 0.7})`);

                    label
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function resetZoom() {
            if (svg && zoom) {
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            d3.selectAll('.node-label').style('display', showLabels ? 'block' : 'none');
        }

        // Extract and render distinct funders
        function renderFunderList(nodes) {
            const funderList = document.getElementById('funder-list');
            if (!funderList || !nodes) return;

            // Count funded wallets per funder
            const funderCounts = new Map();
            nodes.forEach(n => {
                if (n.funded_by) {
                    funderCounts.set(n.funded_by, (funderCounts.get(n.funded_by) || 0) + 1);
                }
            });

            if (funderCounts.size === 0) {
                funderList.innerHTML = '<div class="funder-empty">No funding relationships found</div>';
                return;
            }

            // Sort by count descending
            const sortedFunders = [...funderCounts.entries()].sort((a, b) => b[1] - a[1]);

            let html = '';
            sortedFunders.forEach(([funder, count]) => {
                const isActive = activeFunder === funder;
                html += `
                    <div class="funder-item ${isActive ? 'active' : ''}" 
                         onclick="filterByFunder('${funder}')"
                         title="${funder}">
                        <div class="funder-dot"></div>
                        <div class="funder-address">${funder.slice(0, 8)}...${funder.slice(-6)}</div>
                        <div class="funder-count">${count}</div>
                    </div>
                `;
            });

            funderList.innerHTML = html;
        }

        // Filter map by selected funder
        function filterByFunder(funderAddress) {
            if (activeFunder === funderAddress) {
                // Toggle off if already selected
                clearFunderFilter();
                return;
            }

            activeFunder = funderAddress;

            // Get nodes funded by this address (and the funder itself if present)
            const fundedNodes = allNodes.filter(n => 
                n.funded_by === funderAddress || n.address === funderAddress
            );

            // Get addresses of filtered nodes
            const filteredAddresses = new Set(fundedNodes.map(n => n.address));

            // Get edges involving these nodes
            const filteredEdges = allEdges.filter(e => 
                filteredAddresses.has(e.source) || filteredAddresses.has(e.target)
            );

            // Re-render bubble map with filtered data
            renderBubbleMap(fundedNodes, filteredEdges);
            renderFunderList(allNodes); // Update UI to show active state

            // Show filter badge and clear button
            document.getElementById('filter-badge').style.display = 'inline';
            document.getElementById('funder-clear-btn').classList.remove('hidden');
        }

        // Clear funder filter
        function clearFunderFilter() {
            activeFunder = null;
            applyEdgeFilters(); // Re-apply edge filters with all nodes
            renderFunderList(allNodes);

            // Hide filter badge and clear button
            document.getElementById('filter-badge').style.display = 'none';
            document.getElementById('funder-clear-btn').classList.add('hidden');
        }

        // Token filter state
        let activeTokenFilters = {}; // { 'ROOKIE': true, 'USDC': true, ... }
        let allTokenSymbols = []; // List of unique token symbols in current view

        // Extract and render token filter list
        function renderTokenFilterList(edges) {
            const tokenList = document.getElementById('token-filter-list');
            if (!tokenList || !edges) return;

            // Count edges per token
            const tokenCounts = new Map();
            edges.forEach(e => {
                const symbol = e.token_symbol || 'Unknown';
                tokenCounts.set(symbol, (tokenCounts.get(symbol) || 0) + 1);
            });

            if (tokenCounts.size === 0) {
                tokenList.innerHTML = '<div class="funder-empty">No tokens found</div>';
                return;
            }

            // Store all tokens and initialize filters (all enabled by default)
            allTokenSymbols = [...tokenCounts.keys()].sort();
            allTokenSymbols.forEach(symbol => {
                if (activeTokenFilters[symbol] === undefined) {
                    activeTokenFilters[symbol] = true;
                }
            });

            // Sort by count descending
            const sortedTokens = [...tokenCounts.entries()].sort((a, b) => b[1] - a[1]);

            let html = '';
            sortedTokens.forEach(([symbol, count]) => {
                const isActive = activeTokenFilters[symbol] !== false;
                const color = symbol === 'Unknown' ? '#666' :
                              symbol === 'SOL' || symbol === 'WSOL' ? '#a855f7' :
                              symbol === 'USDC' || symbol === 'USDT' ? '#22c55e' : '#e94560';
                html += `
                    <div class="funder-item ${isActive ? 'active' : ''}"
                         onclick="toggleTokenFilter('${symbol}')"
                         title="${symbol}">
                        <div class="funder-dot" style="background: ${color};"></div>
                        <div class="funder-address" style="color: ${color};">${symbol}</div>
                        <div class="funder-count">${count}</div>
                    </div>
                `;
            });

            tokenList.innerHTML = html;

            // Show/hide clear button
            const anyOff = Object.values(activeTokenFilters).some(v => v === false);
            document.getElementById('token-clear-btn')?.classList.toggle('hidden', !anyOff);
        }

        // Toggle individual token filter
        function toggleTokenFilter(symbol) {
            activeTokenFilters[symbol] = !activeTokenFilters[symbol];
            applyAllFilters();
            renderTokenFilterList(allEdges); // Update UI
        }

        // Clear token filters (enable all)
        function clearTokenFilter() {
            Object.keys(activeTokenFilters).forEach(k => activeTokenFilters[k] = true);
            applyAllFilters();
            renderTokenFilterList(allEdges);
        }

        // Edge category filter state (filter by category, not individual types)
        let activeCategoryFilters = {
            swap: true,      // swap_in, swap_out
            transfer: true,  // spl_transfer, sol_transfer, wallet_funded
            account: true,   // create_ata, close_ata
            fee: true,       // fee, priority_fee, protocol_fee
            lending: true,   // lend_deposit, lend_withdraw, borrow, repay, liquidation
            staking: true,   // stake, unstake, stake_reward
            liquidity: true, // add_liquidity, remove_liquidity, farm_deposit, farm_withdraw, lp_reward
            bridge: true,    // bridge_in, bridge_out
            perp: true,      // perp_*, margin_*, funding_payment, pnl_settlement
            nft: true,       // nft_mint, nft_sale, nft_transfer
            other: true      // mint, burn, airdrop, unknown
        };
        let showFundedBy = true; // Separate toggle for funded_by pseudo-edges

        // Apply all filters (edge types + tokens + funders)
        function applyAllFilters() {
            applyEdgeFilters();
        }

        // Category to edge type mapping
        const categoryMap = {
            'swap': ['swap_in', 'swap_out'],
            'transfer': ['spl_transfer', 'sol_transfer', 'wallet_funded'],
            'account': ['create_ata', 'close_ata'],
            'fee': ['fee', 'priority_fee', 'protocol_fee'],
            'lending': ['lend_deposit', 'lend_withdraw', 'borrow', 'repay', 'liquidation'],
            'staking': ['stake', 'unstake', 'stake_reward'],
            'liquidity': ['add_liquidity', 'remove_liquidity', 'farm_deposit', 'farm_withdraw', 'lp_reward'],
            'bridge': ['bridge_in', 'bridge_out'],
            'perp': ['perp_open', 'perp_close', 'perp_deposit', 'perp_withdraw', 'margin_deposit', 'margin_withdraw', 'margin_call', 'perp_liquidation', 'funding_payment', 'pnl_settlement'],
            'nft': ['nft_mint', 'nft_sale', 'nft_transfer'],
            'other': ['mint', 'burn', 'airdrop', 'unknown']
        };

        // Reverse lookup: edge type -> category
        const typeToCategory = {};
        for (const [cat, types] of Object.entries(categoryMap)) {
            for (const t of types) { typeToCategory[t] = cat; }
        }

        // Apply edge type filters
        function applyEdgeFilters() {
            // Read category checkbox states
            for (const cat of Object.keys(activeCategoryFilters)) {
                const el = document.getElementById(`filter-cat-${cat}`);
                if (el) activeCategoryFilters[cat] = el.checked;
            }
            showFundedBy = document.getElementById('filter-funded_by')?.checked ?? true;

            // Determine which nodes/edges to use (respect funder filter if active)
            let nodesToUse = allNodes;
            let edgesToUse = allEdges;

            if (activeFunder) {
                // Get nodes funded by this address (and the funder itself if present)
                nodesToUse = allNodes.filter(n =>
                    n.funded_by === activeFunder || n.address === activeFunder
                );
                const filteredAddresses = new Set(nodesToUse.map(n => n.address));
                edgesToUse = allEdges.filter(e =>
                    filteredAddresses.has(e.source) || filteredAddresses.has(e.target)
                );
            }

            // Filter edges by category
            let filteredEdges = edgesToUse.filter(e => {
                const edgeType = e.type || 'unknown';
                const category = e.category || typeToCategory[edgeType] || 'other';
                return activeCategoryFilters[category] !== false;
            });

            // Filter edges by token symbol
            filteredEdges = filteredEdges.filter(e => {
                const symbol = e.token_symbol || 'Unknown';
                return activeTokenFilters[symbol] !== false;
            });

            // Check if any filter is off (to show badge)
            const anyCategoryFilterOff = Object.values(activeCategoryFilters).some(v => v === false);
            const anyTokenFilterOff = Object.values(activeTokenFilters).some(v => v === false);
            const badge = document.getElementById('filter-badge');
            if (badge) {
                badge.style.display = (anyCategoryFilterOff || anyTokenFilterOff || !showFundedBy || activeFunder) ? 'inline' : 'none';
            }

            // Re-render with filtered edges (funded_by edges handled in renderBubbleMap)
            renderBubbleMapFiltered(nodesToUse, filteredEdges);
        }

        // Render bubble map with edge type filtering support
        function renderBubbleMapFiltered(nodes, edges) {
            const container = document.getElementById('bubble-map');
            if (!container) return;

            // Clear previous
            container.innerHTML = '';
            d3.selectAll('.tooltip').remove();

            if (!nodes || nodes.length === 0) {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #aaa;">No nodes to display</div>';
                return;
            }

            const width = container.clientWidth;
            const height = 1000;

            // Create node map for lookups
            const nodeMap = new Map(nodes.map(n => [n.address, n]));

            // Calculate balance range for sizing
            const balances = nodes.map(n => Math.max(0, n.balance || 0));
            const maxBalance = Math.max(...balances, 1);
            const minBalance = 0;

            const sizeScale = d3.scaleSqrt()
                .domain([minBalance, maxBalance])
                .range([8, 50]);

            const colorScale = d3.scaleQuantile()
                .domain(balances)
                .range(['#22c55e', '#3b82f6', '#e94560']);

            // Prepare nodes for D3
            const d3Nodes = nodes.map(n => {
                const displayBalance = Math.max(0, n.balance || 0);
                const isZeroBalance = (n.balance || 0) <= 0;
                return {
                    id: n.address,
                    label: n.label || 'wallet',
                    address_type: n.address_type,
                    pool_label: n.pool_label,
                    token_name: n.token_name,
                    balance: n.balance || 0,
                    displayBalance: displayBalance,
                    isZeroBalance: isZeroBalance,
                    sol_balance: n.sol_balance || 0,
                    funded_by: n.funded_by,
                    radius: sizeScale(displayBalance),
                    color: isZeroBalance ? '#666' : colorScale(displayBalance)
                };
            });

            // Track nodes with close_ata events (self-edges where ATA was closed)
            const closeAtaInfo = new Map(); // address -> { amount, sol returned }
            (edges || []).forEach(e => {
                if (e.type === 'close_ata' && e.source === e.target) {
                    closeAtaInfo.set(e.source, {
                        amount: e.amount,
                        ins_index: e.ins_index
                    });
                }
            });

            // Add close_ata info to d3Nodes
            d3Nodes.forEach(n => {
                if (closeAtaInfo.has(n.id)) {
                    n.closeAta = closeAtaInfo.get(n.id);
                }
            });

            // Prepare edges for D3 - only include edges where both nodes exist
            // Filter out self-edges (like close_ata) since they can't be rendered as lines
            const d3Edges = (edges || [])
                .filter(e => nodeMap.has(e.source) && nodeMap.has(e.target) && e.source !== e.target)
                .map(e => ({
                    source: e.source,
                    target: e.target,
                    amount: e.amount,
                    type: e.type,
                    token_symbol: e.token_symbol,
                    token_name: e.token_name,
                    decimals: e.decimals,
                    from_token_balance: e.from_token_balance,
                    to_token_balance: e.to_token_balance,
                    from_sol_balance: e.from_sol_balance,
                    to_sol_balance: e.to_sol_balance,
                    signature: e.signature,
                    block_time: e.block_time,
                    block_time_utc: e.block_time_utc,
                    dex: e.dex,
                    pool: e.pool,
                    program: e.program,
                    ins_index: e.ins_index,
                    source_label: e.source_label,
                    target_label: e.target_label,
                    pool_label: e.pool_label
                }));

            // Add funded_by edges only if filter is enabled
            if (showFundedBy) {
                nodes.forEach(n => {
                    if (n.funded_by && nodeMap.has(n.funded_by)) {
                        d3Edges.push({
                            source: n.funded_by,
                            target: n.address,
                            amount: 0,
                            type: 'funded_by'
                        });
                    }
                });
            }

            // Create SVG
            svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    currentTransform = event.transform;
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);
            g = svg.append('g');

            if (currentTransform !== d3.zoomIdentity) {
                svg.call(zoom.transform, currentTransform);
            }

            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Edge type colors by category
            const edgeColors = {
                // Swap - green/red
                'swap_in': '#22c55e', 'swap_out': '#ef4444',
                // Transfer - blue/purple
                'spl_transfer': '#3b82f6', 'sol_transfer': '#60a5fa', 'wallet_funded': '#a855f7', 'funded_by': '#a855f7',
                // Account - cyan
                'create_ata': '#06b6d4', 'close_ata': '#0891b2',
                // Fee - gray
                'fee': '#6b7280', 'priority_fee': '#4b5563', 'protocol_fee': '#9ca3af',
                // Lending - orange
                'lend_deposit': '#f97316', 'lend_withdraw': '#ea580c', 'borrow': '#fb923c', 'repay': '#fdba74', 'liquidation': '#c2410c',
                // Staking - amber
                'stake': '#f59e0b', 'unstake': '#d97706', 'stake_reward': '#fbbf24',
                // Liquidity - teal
                'add_liquidity': '#14b8a6', 'remove_liquidity': '#0d9488', 'farm_deposit': '#2dd4bf', 'farm_withdraw': '#5eead4', 'lp_reward': '#99f6e4',
                // Bridge - indigo
                'bridge_in': '#6366f1', 'bridge_out': '#818cf8',
                // Perp - rose
                'perp_open': '#f43f5e', 'perp_close': '#fb7185', 'perp_deposit': '#e11d48', 'perp_withdraw': '#be123c',
                'margin_deposit': '#fda4af', 'margin_withdraw': '#fecdd3', 'margin_call': '#9f1239', 'perp_liquidation': '#881337',
                'funding_payment': '#fecaca', 'pnl_settlement': '#fca5a5',
                // NFT - pink
                'nft_mint': '#ec4899', 'nft_sale': '#f472b6', 'nft_transfer': '#f9a8d4',
                // Other
                'mint': '#22d3ee', 'burn': '#ff6b6b', 'airdrop': '#a78bfa', 'unknown': '#475569'
            };

            // Create edges
            const link = g.append('g')
                .selectAll('line')
                .data(d3Edges)
                .join('line')
                .attr('class', 'edge-line')
                .attr('stroke', d => edgeColors[d.type] || '#666')
                .attr('stroke-width', d => ['funded_by', 'fee', 'priority_fee', 'protocol_fee'].includes(d.type) ? 1 : 3)
                .attr('stroke-dasharray', d => ['funded_by', 'create_ata', 'close_ata'].includes(d.type) ? '4,4' : null)
                .style('cursor', d => d.signature ? 'pointer' : 'default')
                .on('mouseover', (event, d) => {
                    if (!d.signature) return;
                    d3.select(event.target).attr('stroke-width', 5);
                    tooltip.transition().duration(200).style('opacity', 1);
                    const tokenSymbol = d.token_symbol || 'Unknown';
                    const tokenName = d.token_name || null;
                    const tokenDisplay = tokenName && tokenName !== tokenSymbol ? `${tokenSymbol} (${tokenName})` : tokenSymbol;
                    const sourceLabel = d.source_label && !['unknown', 'wallet'].includes(d.source_label) ? d.source_label : null;
                    const targetLabel = d.target_label && !['unknown', 'wallet'].includes(d.target_label) ? d.target_label : null;
                    const poolLabel = d.pool_label || null;
                    tooltip.html(`
                        <div style="margin-bottom: 8px;">
                            <span class="edge-type ${d.type}" style="display: inline-block; margin-bottom: 5px;">${d.type}</span>
                            ${d.dex ? `<span style="color: #fbbf24; font-size: 11px; margin-left: 8px;">${d.dex}</span>` : ''}
                        </div>
                        ${sourceLabel || targetLabel ? `
                        <div style="margin-bottom: 8px; font-size: 11px;">
                            ${sourceLabel ? `<div>From: <span style="color: #a855f7;">${sourceLabel}</span></div>` : ''}
                            ${targetLabel ? `<div>To: <span style="color: #22c55e;">${targetLabel}</span></div>` : ''}
                        </div>
                        ` : ''}
                        <div class="stats">
                            Amount: <span style="color: #22c55e; font-weight: bold;">${formatNumber(d.amount)} ${tokenDisplay}</span><br>
                            ${d.from_sol_balance !== null && d.from_sol_balance !== undefined ? `From SOL: <span style="color: #60a5fa;">${d.from_sol_balance.toFixed(6)}</span><br>` : ''}
                            ${d.to_sol_balance !== null && d.to_sol_balance !== undefined ? `To SOL: <span style="color: #60a5fa;">${d.to_sol_balance.toFixed(6)}</span><br>` : ''}
                            Time: ${d.block_time_utc || (d.block_time ? formatTimestamp(d.block_time) : 'N/A')}
                            ${d.ins_index !== null && d.ins_index !== undefined ? `<br>Instruction: <span>#${d.ins_index}</span>` : ''}
                        </div>
                        ${d.pool || d.program || poolLabel ? `
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333; font-size: 10px;">
                            ${poolLabel ? `<div style="margin-bottom: 4px; color: #fbbf24;">${poolLabel}</div>` : ''}
                            ${d.pool ? `<div style="margin-bottom: 4px;">Pool: <span style="color: #e94560;">${d.pool.slice(0,12)}...</span></div>` : ''}
                            ${d.program ? `<div>Program: <span style="color: #3b82f6;">${d.program.slice(0,12)}...</span></div>` : ''}
                        </div>
                        ` : ''}
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                            <div style="color: #aaa; font-size: 10px; margin-bottom: 3px;">Click to navigate:</div>
                            <div class="address" style="font-size: 10px;">${d.signature}</div>
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', (event, d) => {
                    d3.select(event.target).attr('stroke-width', d.type === 'funded_by' ? 1 : 3);
                    tooltip.transition().duration(500).style('opacity', 0);
                })
                .on('click', (event, d) => {
                    if (d.signature) {
                        tooltip.style('opacity', 0);
                        navigateTo(d.signature);
                    }
                });

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(d3Nodes)
                .join('circle')
                .attr('class', 'node-circle')
                .attr('r', d => d.radius)
                .attr('fill', d => d.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', (event, d) => {
                    tooltip.transition().duration(200).style('opacity', 1);
                    const displayName = d.pool_label || d.token_name || null;
                    tooltip.html(`
                        <div class="address">${d.id}</div>
                        ${displayName ? `<div style="color: #fbbf24; font-weight: bold; margin-bottom: 8px;">${displayName}</div>` : ''}
                        <div class="stats">
                            Type: <span style="color: #a855f7;">${d.address_type || d.label}</span><br>
                            Balance: <span>${formatNumber(d.balance)}</span><br>
                            SOL: <span>${d.sol_balance.toFixed(4)}</span>
                            ${d.funded_by ? '<br>Funded by: ' + d.funded_by.slice(0, 20) + '...' : ''}
                            ${d.closeAta ? `<br><span style="color: #0891b2;">ATA Closed: +${d.closeAta.amount.toFixed(6)} SOL</span>` : ''}
                        </div>
                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #333; color: #aaa; font-size: 10px;">
                            Click to fetch wallet transactions
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.transition().duration(500).style('opacity', 0);
                })
                .on('click', (event, d) => {
                    event.stopPropagation();
                    tooltip.style('opacity', 0);
                    fetchWalletTransactions(d.id);
                });

            // Create close_ata badges (small cyan circle with X for nodes that closed an ATA)
            const closeAtaNodes = d3Nodes.filter(d => d.closeAta);
            const badge = g.append('g')
                .selectAll('g')
                .data(closeAtaNodes)
                .join('g')
                .attr('class', 'close-ata-badge')
                .style('cursor', 'pointer')
                .on('mouseover', (event, d) => {
                    tooltip.transition().duration(200).style('opacity', 1);
                    tooltip.html(`
                        <div style="margin-bottom: 5px;">
                            <span class="edge-type close_ata">close_ata</span>
                        </div>
                        <div class="stats">
                            SOL Returned: <span style="color: #0891b2; font-weight: bold;">${d.closeAta.amount.toFixed(6)} SOL</span><br>
                            Instruction: <span>#${d.closeAta.ins_index}</span>
                        </div>
                        <div style="margin-top: 8px; color: #aaa; font-size: 10px;">
                            Token account was closed, rent returned
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.transition().duration(500).style('opacity', 0);
                });

            // Badge background circle
            badge.append('circle')
                .attr('r', 8)
                .attr('fill', '#0891b2')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);

            // Badge X symbol
            badge.append('text')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('fill', '#fff')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .text('X');

            // Create labels
            const label = g.append('g')
                .selectAll('text')
                .data(d3Nodes)
                .join('text')
                .attr('class', 'node-label')
                .text(d => d.id.slice(0, 6) + '...')
                .attr('dy', d => d.radius + 12)
                .style('display', showLabels ? 'block' : 'none');

            // Force simulation
            simulation = d3.forceSimulation(d3Nodes)
                .force('link', d3.forceLink(d3Edges).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 5))
                .on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);

                    // Position badges at top-right of node
                    badge
                        .attr('transform', d => `translate(${d.x + d.radius * 0.7}, ${d.y - d.radius * 0.7})`);

                    label
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Fetch wallet transactions via guide-producer
        async function fetchWalletTransactions(address) {
            showToast(`Fetching transactions for ${address.slice(0,8)}...`, 'pending');
            
            try {
                const response = await fetch('/api/fetch-wallet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast(`Queued ${result.message || 'wallet fetch'}`, 'success');
                } else {
                    showToast(`Error: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            }
        }
        
        function showToast(message, type = 'info') {
            const toast = document.getElementById('fetch-toast');
            toast.textContent = message;
            toast.className = 'fetch-toast show ' + type;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        function formatNumber(num) {
            if (num === null || num === undefined) return '0';
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        // Timeline Variables
        let timelineData = {
            minTime: 0,
            maxTime: 0,
            currentTime: 0,
            txCount: 0
        };
        let sliderDebounce = null;

        async function initTimeline(token) {
            if (!token?.mint && !token?.symbol) return;

            try {
                const params = token.mint
                    ? `mint_address=${token.mint}`
                    : `token_symbol=${token.symbol}`;

                const response = await fetch(`/api/timerange?${params}`);
                const data = await response.json();

                if (data.min_time && data.max_time) {
                    timelineData.minTime = data.min_time;
                    timelineData.maxTime = data.max_time;
                    timelineData.txCount = data.tx_count;

                    // Show timeline section
                    const section = document.getElementById('timeline-section');
                    if (section) section.style.display = 'block';

                    // Update labels
                    document.getElementById('timeline-min-label').textContent =
                        formatTimestamp(data.min_time);
                    document.getElementById('timeline-max-label').textContent =
                        formatTimestamp(data.max_time);
                    document.getElementById('timeline-tx-count').textContent =
                        data.tx_count.toLocaleString();

                    // Setup slider
                    const slider = document.getElementById('timeline-slider');
                    slider.min = data.min_time;
                    slider.max = data.max_time;

                    // Set current position
                    updateTimelinePosition(currentData?.result?.txs?.block_time || data.max_time);

                    // Add event listener
                    slider.removeEventListener('input', onSliderInput);
                    slider.addEventListener('input', onSliderInput);
                }
            } catch (e) {
                console.error('Failed to load timeline:', e);
            }
        }

        function onSliderInput(e) {
            const blockTime = parseInt(e.target.value);
            timelineData.currentTime = blockTime;
            document.getElementById('timeline-current-time').textContent =
                formatTimestamp(blockTime);

            // Debounce the API call
            clearTimeout(sliderDebounce);
            sliderDebounce = setTimeout(() => {
                navigateToTime(blockTime);
            }, 300);
        }

        function restoreTimelineUI() {
            // Restore timeline labels and slider range from stored data
            const minLabel = document.getElementById('timeline-min-label');
            const maxLabel = document.getElementById('timeline-max-label');
            const txCount = document.getElementById('timeline-tx-count');
            const slider = document.getElementById('timeline-slider');

            if (minLabel) minLabel.textContent = formatTimestamp(timelineData.minTime);
            if (maxLabel) maxLabel.textContent = formatTimestamp(timelineData.maxTime);
            if (txCount) txCount.textContent = timelineData.txCount.toLocaleString();

            if (slider) {
                slider.min = timelineData.minTime;
                slider.max = timelineData.maxTime;
                slider.removeEventListener('input', onSliderInput);
                slider.addEventListener('input', onSliderInput);
            }
        }

        function updateTimelinePosition(blockTime) {
            if (!blockTime) return;
            timelineData.currentTime = blockTime;
            const slider = document.getElementById('timeline-slider');
            if (slider) {
                slider.value = blockTime;
            }
            const timeLabel = document.getElementById('timeline-current-time');
            if (timeLabel) {
                timeLabel.textContent = formatTimestamp(blockTime);
            }
        }

        function navigateToTime(blockTime) {
            // Use form values for token identification (not currentData)
            const mintFromForm = document.getElementById('mint_address').value;
            const symbolFromForm = document.getElementById('token_symbol').value;

            if (mintFromForm) {
                fetchData({
                    mint_address: mintFromForm,
                    block_time: blockTime
                });
            } else if (symbolFromForm) {
                fetchData({
                    token_symbol: symbolFromForm,
                    block_time: blockTime
                });
            } else {
                // Fallback to currentData mint (shouldn't normally happen)
                const mint = currentData?.result?.token?.mint;
                if (mint) {
                    fetchData({
                        mint_address: mint,
                        block_time: blockTime
                    });
                }
            }
        }

        function timelineJump(position) {
            if (position === 'start') {
                navigateToTime(timelineData.minTime);
            } else if (position === 'end') {
                navigateToTime(timelineData.maxTime);
            }
        }

        function timelineStep(direction) {
            const txs = currentData?.result?.txs;
            if (!txs) return;

            if (direction === -1 && txs.prev && txs.prev.length > 0) {
                // Go to first previous tx
                navigateTo(txs.prev[0].signature);
            } else if (direction === 1 && txs.next && txs.next.length > 0) {
                // Go to first next tx
                navigateTo(txs.next[0].signature);
            }
        }

        function formatTimestamp(unixTime) {
            if (!unixTime) return '--';
            const date = new Date(unixTime * 1000);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function toggleCollapsible(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            content.classList.toggle('collapsed');
        }

        // Load with default on page load if URL has params
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('token_symbol')) {
            document.getElementById('token_symbol').value = urlParams.get('token_symbol');
            fetchData();
        }
    </script>
</body>
</html>
